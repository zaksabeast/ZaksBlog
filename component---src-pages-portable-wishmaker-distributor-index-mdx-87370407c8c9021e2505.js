(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{B1Ka:function(e,t,o){"use strict";o.r(t),o.d(t,"metadata",(function(){return g})),o.d(t,"_frontmatter",(function(){return f})),o.d(t,"default",(function(){return O}));o("rGqo"),o("yt8O"),o("Btvt"),o("RW0V"),o("91GP"),o("q1tI");var a=o("7ljp"),n=o("m+yu"),i=o("RENv"),s=o.n(i),r=o("ErUr"),l=o.n(r),h=o("r2ES"),b=o.n(h),c=o("ZmHV"),m=o.n(c),d=o("N69E"),u=o.n(d);var p,g={title:"Portable Wishmaker Jirachi Distributor",description:"Building a way to get a Wishmaker Jirachi without a Gamecube",date:"01/01/2021"},f={},w=(p="Image",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),Object(a.b)("div",e)}),y={metadata:g,_frontmatter:f},j=n.a;function O(e){var t=e.components,o=function(e,t){if(null==e)return{};var o,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)o=i[a],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,["components"]);return Object(a.b)(j,Object.assign({},y,o,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",null,"Portable Wishmaker Jirachi Distributor"),Object(a.b)("p",null,"Growing up, I loved playing Pokemon on the Gameboy Advance. It had better graphics than its predecessor, a new part of the world to explore, and of course, new Pokemon. I had fun catching so many amazing Pokemon, but one eluded me: Jirachi."),Object(a.b)("p",null,'Jirachi is part of a class of Pokemon known as "Mythicals". These are traditionally more difficult to obtain and generally aren\'t available in normal gameplay.'),Object(a.b)("p",null,"The Gameboy Advance era coincided with the Gamecube being a popular home console, and the Pokemon company had released a title for the Gamecube called Pokemon Colosseum. People who preordered Colosseum also got a special Colosseum bonus disc that could send Jirachi to a Pokemon game on a Gameboy Advance."),Object(a.b)("p",null,"The Gameboy Advance and Gamecube would communicate with each other through a special link cable. A player would load the Colosseum bonus disc on their Gamecube, turn on their Gameboy Advance with a Pokemon game inserted, watch a special animation, and have Jirachi added to their game. This Jirachi is known as the Wishmaker Jirachi, due to one of its in-game properties."),Object(a.b)("p",null,"This Jirachi can still be obtained today, but it's also still difficult. The Colosseum bonus disc is hard to find, and the cost can be pretty high. In addition, a Gamecube, Gamecube controller, and the special link cable are all required."),Object(a.b)("p",null,"About a week or two ago, I had the idea to make a portable Wishmaker distributor: a small device that could plug into a Gameboy Advance and serve the same function as a Gamecube with the Colosseum bonus disc."),Object(a.b)("h2",null,"Technical details"),Object(a.b)("p",null,'The Gameboy Advance has a feature called "Multiboot". It allows executable binaries to be loaded onto the Gameboy Advance through the game link port normally used to connect multiple Gameboy Advances together for multiplayer games.'),Object(a.b)("p",null,"When booted without a game cartridge, the Gameboy Advance can be sent a multiboot rom that the console will run. This has several applications:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Mini-games loaded from external sources (e.g. e-reader and Gamecube)"),Object(a.b)("li",{parentName:"ul"},"Multiplayer with only one game cartridge (e.g. a racing game can load a mini-version of itself on a friend's console who doesn't have the game)"),Object(a.b)("li",{parentName:"ul"},"Companion games (e.g. loading a map of a Gamecube game world on the Gameboy Advance)")),Object(a.b)("p",null,"The Colosseum bonus disc transfers Jirachi by loading a multiboot rom onto the Gameboy Advance. The Gameboy Advance runs the multiboot rom, and the multiboot rom adds a Jirachi to the game cartridge inserted into the Gameboy Advance."),Object(a.b)("p",null,"With this in mind, the entire process of getting Jirachi is almost entirely contained within the Gameboy Advance. The Gamecube is purely a method of transporting the multiboot rom, so it should be possible to remove the Gamecube from the setup by replacing it with some other device that can load multiboot roms onto a Gameboy Advance."),Object(a.b)("h2",null,"Building a multiboot loader"),Object(a.b)("p",null,"Having the ability to load arbitrary software onto a Gameboy Advance is not a new concept. For years, hobbiest developers have used this feature of the Gameboy Advance to load homebrew, custom homemade software, onto the Gameboy Advance."),Object(a.b)("p",null,"As a result, there have been lots of tools made over the years built for this exact purpose."),Object(a.b)("p",null,"I had a teensy 3.2 that I wanted to use for this project, so I set off on my journey to find someone who had already solved this problem."),Object(a.b)("p",null,"Over the years, the solutions to send multiboot roms to a Gameboy Advance from a computer have changed quite a bit. The first solution was to use a serial port on the computer. As modern computers lost their serial ports, ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/cartr/MSMCcable"}),"the solution was ported to arduinos"),", which can interact with computers via usb."),Object(a.b)("p",null,"The arduino port largely kept the original code with small tweaks for the arduino. Unfortunately, this could no longer be compiled due to updates that have been made to the arduino since then."),Object(a.b)("p",null,"I found a more recent version by MerryMage that was built ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/MerryMage/gba-multiboot"}),"to work with the teensy"),". Sadly, this too was several years out of date and wouldn't compile for the teensy 3.2."),Object(a.b)("p",null,"It didn't look like any other solution existed to serve the purpose I was looking for, so I had to update it myself."),Object(a.b)("p",null,"All of the previous versions used interrupts to time communication with the Gameboy Advance. Using interrupts can be useful for many situations, however it's also somewhat discouraged depending on the situation since interrupts can be error prone, aren't always easy to reason about, and the same results can often be accomplished in other ways."),Object(a.b)("p",null,"MerryMage's solution referenced some ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"http://www.akkit.org/info/gba_comms.html"}),"technical documentation")," that explained how the Gameboy Advance serial connection works, which allowed me to rewrite the communication. To ensure timing issues wouldn't occur, I slowed the teensy's processing speed down to a level the Gameboy Advance wouldn't have trouble communicating with."),Object(a.b)(w,{src:l.a,mdxType:"Image"}),Object(a.b)("p",null,"And it works! I was able to load the example ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/MerryMage/gba-multiboot/tree/master/gba-hello-world"}),'"Hello World" homebrew')," that was provided in MerryMage's multiboot loader. The next step was to load the Wishmaker multiboot rom."),Object(a.b)("h2",null,"Dumping the Wishmaker multiboot"),Object(a.b)("p",null,"The Wishmaker multiboot file needed to be somewhere on the Colosseum bonus disc. The first step of examining any game's files is to get a copy of the game. I have a hacked Wii that can dump Gamecube and Wii games using a homebrew called ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://wiibrew.org/wiki/CleanRip"}),"CleanRip"),"."),Object(a.b)("p",null,"With the ISO in hand, I needed a way to mount the game so the files could be examined. With most USBs or discs, a computer will know how to mount the filesystem in a way that allows a user to interact with it like any other directory containing files. However Gamecube games use a special format that computers normally don't recognize."),Object(a.b)("p",null,"Being a Linux user, I'm pretty fond of using FUSE to tell my computer how to mount such files. A quick google search showed ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/multimediamike/gcfuse"}),"gcfuse")," provides this exact functionality."),Object(a.b)("p",null,"Fortunately, I found several files that looked like they would be of interest, and one that stood out had the ",Object(a.b)("inlineCode",{parentName:"p"},".tgc")," extension. Online searches brought me to ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://www.retroreversing.com/gamecube-file-formats#games-which-have-tgc-files-mostly-demos"}),"this site"),", which said the TGC format was used mostly for demos, and listed the Wishmaker Jirachi as an example."),Object(a.b)("p",null,"The TGC file is a Gamecube format, not a Gameboy Advance format, so the multboot rom needed to be extracted from the TGC file. Game consoles tend to have several unique formats, and communities of game hackers love to write the tools necessary to extract and modify those files."),Object(a.b)("p",null,"The next search result led me to ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/fuzziqersoftware/gctools"}),"gctools"),", a collection of tools for Gamecube specific formats, and it happened to have a tool that supported TGC, ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/fuzziqersoftware/gctools/blob/master/gcmdump.cc"}),"gcmdump"),". With this, I was able to extract several files from the TGC file."),Object(a.b)("p",null,"I had known from reading an old post on ProjectPokemon several months ago that the Colosseum bonus disc also included an unreleased (probably test) Jirachi: the Meteor Jirachi. Based on that, there were two files that looked like they would be what I was looking for: ",Object(a.b)("inlineCode",{parentName:"p"},"client.bin")," and ",Object(a.b)("inlineCode",{parentName:"p"},"client.2003_1112.bin"),"."),Object(a.b)("p",null,'The file names and file sizes showed the two files were possibly different versions of the same file, and they were both small enough to be a multiboot rom. The phrase "client of pokedownload" also seemed like it would be the client sent to the Gameboy Advance to save Jirachi to a Pokemon game.'),Object(a.b)("p",null,"A comparison of the files also showed similar rom headers."),Object(a.b)("p",null,"Finally, I sent ",Object(a.b)("inlineCode",{parentName:"p"},"client.bin")," to my console to see if it would load."),Object(a.b)(w,{src:b.a,mdxType:"Image"}),Object(a.b)("p",null,"It worked! Partially. Normally a message would be shown to tell the user the Jirachi was being sent to the game, which wasn't being shown."),Object(a.b)("p",null,"It turns out there are a few issues with getting the Wishmaker multiboot rom to load on a console in this way."),Object(a.b)("h2",null,"Loading Wishmaker without a Gamecube"),Object(a.b)("p",null,"The Gameboy Advance only boots into multiboot roms when a game cartridge isn't inserted. However, the Wishmaker rom expects a game cartridge to be inserted into the Gameboy Advance so it can add a Jirachi to the cartridge's save file."),Object(a.b)("p",null,"To figure out how this works, I referenced a ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/pret/pokeruby"}),"disassembly of Pokemon Ruby and Sapphire by PRET"),". This repository is an effort to disassemble the Pokemon games back into what their original C code probably looked like. There still are traces of assembly, but most things are labeled. This makes it a great place to look at how older games work."),Object(a.b)("p",null,"PRET's repository has ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/pret/pokeruby/blob/aa6947d5b11bd93fe36cb71377894a454287325b/src/libs/libgcnmultiboot.s"}),"an entire file dedicated to the Gamecube multiboot"),"."),Object(a.b)("p",null,"Ruby and Sapphire appear to continue accepting the multiboot rom after the game has loaded and jumps execution to the multiboot rom if it passes a few checks. There are a few times the multiboot rom will fail to load. Among other things:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"The header or checksum is invalid"),Object(a.b)("li",{parentName:"ul"},"Data transfer is too slow"),Object(a.b)("li",{parentName:"ul"},"A handshake with the Gamecube is not successful")),Object(a.b)("p",null,"The first scenario isn't a concern since I was already able to load a custom homebrew onto the console."),Object(a.b)("p",null,"The second scenario shouldn't be a problem, as I was able to load the Wishmaker fairly quickly with the teensy."),Object(a.b)("p",null,"The third scenario would cause issues since the teensy wasn't programmed to do a handshake after it started loading a multiboot rom."),Object(a.b)("p",null,"I started looking a little bit into what the Pokemon game was expecting of the Gamecube, but figured there was a faster way to work around this issue with some other added benefits."),Object(a.b)("h2",null,"Creating a bootstrap homebrew"),Object(a.b)("p",null,"To boot into a multiboot rom, the Gameboy Advance requires no cartridge to be inserted, but the Wishmaker multiboot rom requires Pokemon Ruby or Sapphire inserted when it loads so it can add Jirachi."),Object(a.b)("p",null,"To work around this, Ruby and Sapphire jump execution to the multiboot rom. Rather than figuring out how the handshake between Ruby and Sapphire and the Gamecube worked, I decided to write a custom homebrew with a multiboot rom embedded in it. When it detected a cartridge was inserted, it would jump to the multiboot rom."),Object(a.b)("p",null,"Having the Gameboy Advance detect whether the cartridge was inserted or not would prevent a situation where the console was unable to read the cartridge (as is often the case with older game consoles)."),Object(a.b)("p",null,"Another benefit with a custom homebrew is the future possibilities. A fun future design would be for the teensy to read multiboot roms off of an SD card. After the Gameboy Advance booted the bootstrap homebrew, it could ask the teensy for a list of available roms. When a cartridge is inserted, the user could select which rom they'd like to load onto their Gameboy Advance."),Object(a.b)("p",null,"In order to see how the console is able to detect if a game cart is inserted, I referenced another homebrew I have used several times by FIX94 called ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/FIX94/gba-link-cable-dumper"}),"gba-link-cable-dumper"),". This homebrew runs on a Gamecube or Wii, sends a custom multiboot homebrew to a Gameboy Advance, and allows the Gameboy Advance to dump a cartridge's save or rom, among other things."),Object(a.b)("p",null,"I found what I needed inside of there and built the bootstrap homebrew. It didn't take too long, worked really well, and I even prototyped out a functional selection menu to boot from a list of multiboot roms."),Object(a.b)(w,{src:m.a,mdxType:"Image"}),Object(a.b)("p",null,"The bootstrap homebrew worked great. However, this only solved the problem of loading the Wishmaker multiboot rom when a game cartridge is not inserted into the console. It didn't solve the issue of text not appearing when the Wishmaker multiboot rom starts."),Object(a.b)("h2",null,"Solving the blank text issue"),Object(a.b)("p",null,"After some digging, I found FIX94 had another cool Gamecube/Wii homebrew that I thought might shed some insight into what I was seeing, ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/FIX94/gba-link-cable-rom-sender/"}),"gba-link-cable-rom-sender"),". This is a Gamecube/Wii homebrew that takes a multiboot rom from the SD card and sends it to a Gameboy Advance; exactly what I was doing."),Object(a.b)("p",null,"As it turns out, there was ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/FIX94/gba-link-cable-rom-sender/issues/1"}),"one issue")," on that repo, and it was my exact problem. Some multiboot roms do a handshake with the Gamecube before running. I wondered if FIX94 decided to implement handshake handling to solve the issue, but they ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/FIX94/gba-link-cable-rom-sender/commit/702142150be526d09b608ba3f54f0239a1685e66"}),"opted to patch the multiboot rom to remove the handshake"),"."),Object(a.b)("p",null,"I felt it would be faster for me to go this same route rather than having the teensy emulate the Gamecube handshake. FIX94's patch is specific to the game listed on their project's issue. In order to get Wishmaker working, I needed to reverse engineer the game and patch it myself."),Object(a.b)("h2",null,"Patching out the handshake"),Object(a.b)("p",null,"My reverse engineering tool of choice is Ghidra. Ghidra has a decent amount of plugins for loading binaries for all sorts of platforms, and the Gameboy Advance is no exception thanks to ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/SiD3W4y/GhidraGBA"}),"SiD3W4y's GhidraGBA"),"."),Object(a.b)("p",null,"At first, it appeared Ghidra had trouble loading the multiboot rom, and could only show me the entrypoint. I figured the rest was either compressed or encrypted, and would need some additional unpacking before I could see what I wanted to see."),Object(a.b)("p",null,"The entrypoint made three system calls."),Object(a.b)(w,{src:s.a,mdxType:"Image"}),Object(a.b)("p",null,Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/mgba-emu/mgba/blob/b3d97a4389840e539751b5b494ad0edb1dd7b793/include/mgba/internal/gba/bios.h#L17"}),"This list of system calls in mgba")," showed the RAM was being reset and data was being decompressed. Referencing the last system call in ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/devkitPro/libgba/blob/master/src/Compression.c#L38-L42"}),"libgba also confirmed this"),"."),Object(a.b)("p",null,"To decompress the multiboot rom code, I had to find an LZ77 decompressor. I found such a script at the bottom of the ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://wiibrew.org/wiki/LZ77#Example_Code"}),"WiiBrew wiki's LZ77 page"),"."),Object(a.b)("p",null,"And with that, I was able to extract the compressed part of the multiboot rom, decompress it as a separate file, and load it into Ghidra."),Object(a.b)("p",null,"Thanks to ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://mgba-emu.github.io/gbatek/"}),"GBATEK's GBA technical documentation"),", I was able to make sense of the hardware registers labeled by GhidraGBA. This allowed me to find the hardware registers for serial communication, see what other parts of the code referenced them, and find where the Gamecube handshake was occuring."),Object(a.b)("p",null,"With the location known, I was able to patch out the instruction that calls the handshake routine."),Object(a.b)(w,{src:u.a,mdxType:"Image"}),Object(a.b)("h2",null,"Final product"),Object(a.b)("p",null,"Everything works!"),Object(a.b)("p",null,'Normally the Gamecube plays an animation that looks like Jirachi flies around the screen before flying into the Gameboy Advance. A funny side effect of the teensy setup is how long it feels like the Gameboy Advance sits "talking to the Gamecube" since there is no animation to watch. I haven\'t timed it yet, but it feels like the Gamecube animation is a lot longer than I remember.'),Object(a.b)("p",null,"It's not quite portable yet. The next steps for this project would be to enclose everything in a nice case and figure out a better way to plug it into the console. Either a link cable should plug in to the teensy and the Gameboy Advance or the teensy should appear almost like a thumbdrive that plugs into the console directly."),Object(a.b)("p",null,"The teensy should also read from an SD card. Since the teensy doesn't have enough space by itself, a computer has to send the custom homebrew to the teensy, which isn't as portable as I'd like it to be."),Object(a.b)("p",null,"The computer side should be able to run from a smartphone, so the current setup is more portable than lugging around a Gamecube and TV everywhere, but there are still iterations that can be made."))}O.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-portable-wishmaker-distributor-index-mdx-87370407c8c9021e2505.js.map